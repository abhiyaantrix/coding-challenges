#!/usr/bin/env ruby

# frozen_string_literal: true

require 'pathname'

# TocGenerator
#
# This class generates a table of contents (TOC) in markdown format for a given directory structure.
# It organizes files by language and folder, creating a hierarchical TOC.
#
# Usage:
#   toc_generator = TocGenerator.new(source_dir, output_file)
#   toc_generator.generate
#
# @param source_dir [String] The directory to scan for files
# @param output_file [String] The file to write the generated TOC to
class TocGenerator

  LANGUAGES = {
    'Ruby' => ['.rb'],
    'TypeScript' => ['.ts'],
    'JavaScript' => ['.js']
  }.freeze

  def initialize(source_dir, output_file)
    @source_dir = Pathname.new(source_dir).expand_path
    @output_file = Pathname.new(output_file).expand_path
  end

  def generate
    content = []
    content << script_note
    content << build_markdown_toc

    write_to_file(content)

    puts "Table of contents generated and written to #{output_file}"
  end

  private

  attr_reader :source_dir, :output_file

  def write_to_file(content)
    File.open(output_file, 'w') do |file|
      content.each { |item| file.write(item) }
    end
  end

  def script_note
    script_path = __FILE__

    <<~MARKDOWN
      <!-- This file is automatically generated using '#{script_path}' -->

    MARKDOWN
  end

  def build_markdown_toc
    folder_map = build_folder_map

    generate_toc(folder_map)
  end

  def build_folder_map
    folder_map = initialize_folder_map

    Pathname.new(source_dir).find do |path|
      process_file(path, folder_map) unless path.directory?
    end

    folder_map
  end

  def initialize_folder_map
    Hash.new { |hash, key| hash[key] = Hash.new { |h, k| h[k] = [] } }
  end

  def process_file(path, folder_map)
    relative_path = path.relative_path_from(Pathname.new(source_dir))

    language = get_language(relative_path.extname)

    add_to_folder_map(folder_map, language, relative_path) if language
  end

  def get_language(ext)
    LANGUAGES.find { |_, exts| exts.include?(ext) }&.first
  end

  def add_to_folder_map(folder_map, language, relative_path)
    folder = relative_path.dirname.to_s.split('/').last.capitalize
    file = relative_path.basename.to_s.split('.').first

    link_path = source_dir_relative_path.join(relative_path)

    folder_map[language][folder] << { file: "* [#{file.capitalize}](#{link_path})", sort_key: file }
  end

  def source_dir_relative_path
    @source_dir_relative_path ||= begin
      root_dir = Pathname.new(Dir.pwd)

      src_dir = root_dir.join(source_dir)
      docs_dir = root_dir.join(output_file).parent

      src_dir.relative_path_from(docs_dir)
    end
  end

  def generate_toc(folder_map)
    folder_map.map { |language, folders| generate_language_section(language, folders) }.join
  end

  def generate_language_section(language, folders)
    <<~MARKDOWN
      ### #{language}

      #{folders.map { |folder, files| generate_folder_section(folder, files) }.join}
    MARKDOWN
  end

  def generate_folder_section(folder, files)
    sorted_files = sort_files(files)

    <<~MARKDOWN
      #### #{folder}

      #{sorted_files.map { |entry| entry[:file] }.join("\n")}

    MARKDOWN
  end

  def sort_files(files)
    files.sort_by { |entry| entry[:sort_key].split(/(\d+)/).map { |part| part.match?(/^\d+$/) ? part.to_i : part } }
  end

end

# Execute
generator = TocGenerator.new('src', 'docs/challenges.md')
generator.generate
